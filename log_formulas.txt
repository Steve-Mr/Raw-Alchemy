"""
Fujifilm F-Log Log Encoding
===========================

Define the *Fujifilm F-Log* log encoding.

-   :func:`colour.models.log_encoding_FLog`
-   :func:`colour.models.log_decoding_FLog`
-   :func:`colour.models.log_encoding_FLog2`
-   :func:`colour.models.log_decoding_FLog2`

References
----------
-   :cite:`Fujifilm2022` : Fujifilm. (2022). F-Log Data Sheet Ver.1.1 (pp.
    1-4). https://dl.fujifilm-x.com/support/lut/F-Log_DataSheet_E_Ver.1.1.pdf
-   :cite:`Fujifilm2022a` : Fujifilm. (2022). F-Log2 Data Sheet Ver.1.0 (pp.
    1-4). https://dl.fujifilm-x.com/support/lut/F-Log2_DataSheet_E_Ver.1.0.pdf
"""

from __future__ import annotations

import numpy as np

from colour.hints import (  # noqa: TC001
    Domain1,
    Range1,
)
from colour.models.rgb.transfer_functions import full_to_legal, legal_to_full
from colour.utilities import Structure, as_float, from_range_1, optional, to_domain_1

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "CONSTANTS_FLOG",
    "CONSTANTS_FLOG2",
    "log_encoding_FLog",
    "log_decoding_FLog",
    "log_encoding_FLog2",
    "log_decoding_FLog2",
]

CONSTANTS_FLOG: Structure = Structure(
    cut1=0.00089,
    cut2=0.100537775223865,
    a=0.555556,
    b=0.009468,
    c=0.344676,
    d=0.790453,
    e=8.735631,
    f=0.092864,
)
"""*Fujifilm F-Log* constants."""

CONSTANTS_FLOG2: Structure = Structure(
    cut1=0.000889,
    cut2=0.100686685370811,
    a=5.555556,
    b=0.064829,
    c=0.245281,
    d=0.384316,
    e=8.799461,
    f=0.092864,
)
"""*Fujifilm F-Log2* colourspace constants."""


def log_encoding_FLog(
    in_r: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Fujifilm F-Log* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    in_r
        Linear reflection data :math:`in`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Fujifilm F-Log* non-linear data :math:`out` is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`in` to a camera is reflection.
    constants
        *Fujifilm F-Log* constants.

    Returns
    -------
    :class:`numpy.ndarray`
        *Fujifilm F-Log* non-linear encoded data :math:`out`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``in_r``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``out_r``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Fujifilm2022`

    Examples
    --------
    >>> log_encoding_FLog(0.18)  # doctest: +ELLIPSIS
    0.4593184...

    The values of *2-2. F-Log Code Value* table in :cite:`Fujifilm2022`
    are obtained as follows:

    >>> x = np.array([0, 18, 90]) / 100
    >>> np.around(log_encoding_FLog(x, 10, False) * 100, 1)
    array([  3.5,  46.3,  73.2])
    >>> np.around(log_encoding_FLog(x) * (2**10 - 1)).astype(np.int_)
    array([ 95, 470, 705])
    """

    in_r = to_domain_1(in_r)
    constants = optional(constants, CONSTANTS_FLOG)

    if not in_reflection:
        in_r = in_r * 0.9

    cut1 = constants.cut1
    a = constants.a
    b = constants.b
    c = constants.c
    d = constants.d
    e = constants.e
    f = constants.f

    out_r = np.where(
        in_r < cut1,
        e * in_r + f,
        c * np.log10(a * in_r + b) + d,
    )

    out_r_cv = out_r if out_normalised_code_value else legal_to_full(out_r, bit_depth)

    return as_float(from_range_1(out_r_cv))


def log_decoding_FLog(
    out_r: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Fujifilm F-Log* log decoding inverse opto-electronic transfer

    function (OETF).

    Parameters
    ----------
    out_r
        *Fujifilm F-Log* non-linear encoded data :math:`out`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Fujifilm F-Log* non-linear data :math:`out` is encoded as
        normalised code values.
    out_reflection
        Whether the light level :math:`in` to a camera is reflection.
    constants
        *Fujifilm F-Log* constants.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear reflection data :math:`in`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``out_r``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``in_r``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Fujifilm2022`

    Examples
    --------
    >>> log_decoding_FLog(0.45931845866162124)  # doctest: +ELLIPSIS
    0.1800000...
    """

    out_r = to_domain_1(out_r)
    constants = optional(constants, CONSTANTS_FLOG)

    out_r = out_r if in_normalised_code_value else full_to_legal(out_r, bit_depth)

    cut2 = constants.cut2
    a = constants.a
    b = constants.b
    c = constants.c
    d = constants.d
    e = constants.e
    f = constants.f

    in_r = np.where(
        out_r < cut2,
        (out_r - f) / e,
        (10 ** ((out_r - d) / c)) / a - b / a,
    )

    if not out_reflection:
        in_r = in_r / 0.9

    return as_float(from_range_1(in_r))


def log_encoding_FLog2(
    in_r: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Fujifilm F-Log2* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    in_r
        Linear reflection data :math:`in`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Fujifilm F-Log2* non-linear data :math:`out` is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`in` to a camera is reflection.
    constants
        *Fujifilm F-Log2* constants.

    Returns
    -------
    :class:`numpy.floating` or :class:`numpy.ndarray`
        *Fujifilm F-Log2* non-linear encoded data :math:`out`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``in_r``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``out_r``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Fujifilm2022a`

    Examples
    --------
    >>> log_encoding_FLog2(0.18)  # doctest: +ELLIPSIS
    0.3910072...

    The values of *2-2. F-Log2 Code Value* table in
    :cite:`Fujifilm2022a` are obtained as follows:

    >>> x = np.array([0, 18, 90]) / 100
    >>> np.around(log_encoding_FLog2(x, 10, False) * 100, 1)
    array([  3.5,  38.4,  57.8])
    >>> np.around(log_encoding_FLog2(x) * (2**10 - 1)).astype(np.int_)
    array([ 95, 400, 570])
    """

    constants = optional(constants, CONSTANTS_FLOG2)

    return log_encoding_FLog(
        in_r, bit_depth, out_normalised_code_value, in_reflection, constants
    )


def log_decoding_FLog2(
    out_r: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Fujifilm F-Log2* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    out_r
        *Fujifilm F-Log2* non-linear encoded data :math:`out`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Fujifilm F-Log2* non-linear data :math:`out` is encoded as
        normalised code values.
    out_reflection
        Whether the light level :math:`in` to a camera is reflection.
    constants
        *Fujifilm F-Log2* constants.

    Returns
    -------
    :class:`numpy.floating` or :class:`numpy.ndarray`
        Linear reflection data :math:`in`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``out_r``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``in_r``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Fujifilm2022a`

    Examples
    --------
    >>> log_decoding_FLog2(0.39100724189123004)  # doctest: +ELLIPSIS
    0.1799999...
    """

    constants = optional(constants, CONSTANTS_FLOG2)

    return log_decoding_FLog(
        out_r, bit_depth, in_normalised_code_value, out_reflection, constants
    )
"""
Sony Encodings
==============

Define the *Sony* log encodings.

-   :func:`colour.models.log_encoding_SLog`
-   :func:`colour.models.log_decoding_SLog`
-   :func:`colour.models.log_encoding_SLog2`
-   :func:`colour.models.log_decoding_SLog2`
-   :func:`colour.models.log_encoding_SLog3`
-   :func:`colour.models.log_decoding_SLog3`

References
----------
-   :cite:`SonyCorporation2012a` : Sony Corporation. (2012). S-Log2 Technical
    Paper (pp. 1-9). https://drive.google.com/file/d/\
1Q1RYri6BaxtYYxX0D4zVD6lAmbwmgikc/view?usp=sharing
-   :cite:`SonyCorporationd` : Sony Corporation. (n.d.). Technical Summary
    for S-Gamut3.Cine/S-Log3 and S-Gamut3/S-Log3 (pp. 1-7).
    http://community.sony.com/sony/attachments/sony/\
large-sensor-camera-F5-F55/12359/2/TechnicalSummary_for_S-Gamut3Cine_S-Gamut3_S-Log3_V1_00.pdf
"""

from __future__ import annotations

import numpy as np

from colour.hints import (  # noqa: TC001
    Domain1,
    Range1,
)
from colour.models.rgb.transfer_functions import full_to_legal, legal_to_full
from colour.utilities import (
    as_float,
    as_float_array,
    domain_range_scale,
    from_range_1,
    to_domain_1,
)

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "log_encoding_SLog",
    "log_decoding_SLog",
    "log_encoding_SLog2",
    "log_decoding_SLog2",
    "log_encoding_SLog3",
    "log_decoding_SLog3",
]


def log_encoding_SLog(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Sony S-Log* log encoding opto-electronic transfer function
    (OETF).

    Parameters
    ----------
    x
        Reflection or :math:`IRE / 100` input light level :math:`x` to a
        camera.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Sony S-Log* non-linear data :math:`y` is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Sony S-Log* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyCorporation2012a`

    Examples
    --------
    >>> log_encoding_SLog(0.18)  # doctest: +ELLIPSIS
    0.3849708...

    The values of *IRE and CV of S-Log2 @ISO800* table in
    :cite:`SonyCorporation2012a` are obtained as follows:

    >>> x = np.array([0, 18, 90]) / 100
    >>> np.around(log_encoding_SLog(x, 10, False) * 100).astype(np.int_)
    array([ 3, 38, 65])
    >>> np.around(log_encoding_SLog(x) * (2**10 - 1)).astype(np.int_)
    array([ 90, 394, 636])
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    y = np.where(
        x >= 0,
        ((0.432699 * np.log10(x + 0.037584) + 0.616596) + 0.03),
        x * 5 + 0.030001222851889303,
    )

    y_cv = full_to_legal(y, bit_depth) if out_normalised_code_value else y

    return as_float(from_range_1(y_cv))


def log_decoding_SLog(
    y: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Sony S-Log* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    y
        *Sony S-Log* non-linear encoded data :math:`y`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Sony S-Log* non-linear data :math:`y` is encoded as
        normalised code values.
    out_reflection
        Whether the output light level :math:`x` represents reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Reflection or :math:`IRE / 100` input light level :math:`x` to a
        camera.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyCorporation2012a`

    Examples
    --------
    >>> log_decoding_SLog(0.384970815928670)  # doctest: +ELLIPSIS
    0.1...
    """

    y = to_domain_1(y)

    x = legal_to_full(y, bit_depth) if in_normalised_code_value else y

    with domain_range_scale("ignore"):
        x = np.where(
            y >= log_encoding_SLog(0.0, bit_depth, in_normalised_code_value),
            10 ** ((x - 0.616596 - 0.03) / 0.432699) - 0.037584,
            (x - 0.030001222851889303) / 5.0,
        )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


def log_encoding_SLog2(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Sony S-Log2* log encoding opto-electronic transfer function
    (OETF).

    Parameters
    ----------
    x
        Reflection or :math:`IRE / 100` input light level :math:`x` to a
        camera.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Sony S-Log2* non-linear data :math:`y` is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Sony S-Log2* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyCorporation2012a`

    Examples
    --------
    >>> log_encoding_SLog2(0.18)  # doctest: +ELLIPSIS
    0.3395325...

    The values of *IRE and CV of S-Log2 @ISO800* table in
    :cite:`SonyCorporation2012a` are obtained as follows:

    >>> x = np.array([0, 18, 90]) / 100
    >>> np.around(log_encoding_SLog2(x, 10, False) * 100).astype(np.int_)
    array([ 3, 32, 59])
    >>> np.around(log_encoding_SLog2(x) * (2**10 - 1)).astype(np.int_)
    array([ 90, 347, 582])
    """

    x = as_float_array(x)

    return log_encoding_SLog(
        x * 155 / 219, bit_depth, out_normalised_code_value, in_reflection
    )


def log_decoding_SLog2(
    y: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Sony S-Log2* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    y
        *Sony S-Log2* non-linear encoded data :math:`y`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Sony S-Log2* non-linear data :math:`y` is encoded as
        normalised code values.
    out_reflection
        Whether the output light level :math:`x` represents reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Reflection or :math:`IRE / 100` input light level :math:`x` to a
        camera.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyCorporation2012a`

    Examples
    --------
    >>> log_decoding_SLog2(0.339532524633774)  # doctest: +ELLIPSIS
    0.1...
    """

    return (
        219
        * log_decoding_SLog(y, bit_depth, in_normalised_code_value, out_reflection)
        / 155
    )


def log_encoding_SLog3(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Sony S-Log3* log encoding opto-electronic transfer function
    (OETF).

    Parameters
    ----------
    x
        Reflection or :math:`IRE / 100` input light level :math:`x` to a
        camera.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Sony S-Log3* non-linear data data :math:`y` is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Sony S-Log3* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyCorporationd`

    Examples
    --------
    >>> log_encoding_SLog3(0.18)  # doctest: +ELLIPSIS
    0.4105571...

    The values of *S-Log3 10bit code values (18%, 90%)* table in
    :cite:`SonyCorporationd` are obtained as follows:

    >>> x = np.array([0, 18, 90]) / 100
    >>> np.around(log_encoding_SLog3(x, 10, False) * 100).astype(np.int_)
    array([ 4, 41, 61])
    >>> np.around(log_encoding_SLog3(x) * (2**10 - 1)).astype(np.int_)
    array([ 95, 420, 598])
    """

    x = to_domain_1(x)

    if not in_reflection:
        x = x * 0.9

    y = np.where(
        x >= 0.01125000,
        (420 + np.log10((x + 0.01) / (0.18 + 0.01)) * 261.5) / 1023,
        (x * (171.2102946929 - 95) / 0.01125000 + 95) / 1023,
    )

    y_cv = y if out_normalised_code_value else legal_to_full(y, bit_depth)

    return as_float(from_range_1(y_cv))


def log_decoding_SLog3(
    y: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Sony S-Log3* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    y
        *Sony S-Log3* non-linear encoded data :math:`y`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Sony S-Log3* non-linear data :math:`y` is encoded as
        normalised code values.
    out_reflection
        Whether the output light level :math:`x` represents reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Reflection or :math:`IRE / 100` input light level :math:`x` to a
        camera.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyCorporationd`

    Examples
    --------
    >>> log_decoding_SLog3(0.410557184750733)  # doctest: +ELLIPSIS
    0.1...
    """

    y = to_domain_1(y)

    y = y if in_normalised_code_value else full_to_legal(y, bit_depth)

    x = np.where(
        y >= 171.2102946929 / 1023,
        ((10 ** ((y * 1023 - 420) / 261.5)) * (0.18 + 0.01) - 0.01),
        (y * 1023 - 95) * 0.01125000 / (171.2102946929 - 95),
    )

    if not out_reflection:
        x = x / 0.9

    return as_float(from_range_1(x))
"""
Panasonic V-Log Log Encoding
============================

Define the *Panasonic V-Log* log encoding.

-   :func:`colour.models.log_encoding_VLog`
-   :func:`colour.models.log_decoding_VLog`

References
----------
-   :cite:`Panasonic2014a` : Panasonic. (2014). VARICAM V-Log/V-Gamut (pp.
    1-7).
    http://pro-av.panasonic.net/en/varicam/common/pdf/VARICAM_V-Log_V-Gamut.pdf
"""

from __future__ import annotations

import numpy as np

from colour.hints import (  # noqa: TC001
    Domain1,
    Range1,
)
from colour.models.rgb.transfer_functions import full_to_legal, legal_to_full
from colour.utilities import Structure, as_float, from_range_1, optional, to_domain_1

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "CONSTANTS_VLOG",
    "log_encoding_VLog",
    "log_decoding_VLog",
]

CONSTANTS_VLOG: Structure = Structure(
    cut1=0.01, cut2=0.181, b=0.00873, c=0.241514, d=0.598206
)
"""*Panasonic V-Log* constants."""


def log_encoding_VLog(
    L_in: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Panasonic V-Log* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    L_in
        Linear reflection data :math:`L_{in}`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Panasonic V-Log* non-linear data :math:`V_{out}` is
        encoded as normalised code values.
    in_reflection
        Whether the light level :math:`L_{in}` to a camera is reflection.
    constants
        *Panasonic V-Log* constants.

    Returns
    -------
    :class:`numpy.ndarray`
        *Panasonic V-Log* mon-linear encoded data :math:`V_{out}`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``L_in``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``V_out``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Panasonic2014a`

    Examples
    --------
    >>> log_encoding_VLog(0.18)  # doctest: +ELLIPSIS
    0.4233114...

    The values of *Fig.2.2 V-Log Code Value* table in :cite:`Panasonic2014a`
    are obtained as follows:

    >>> L_in = np.array([0, 18, 90]) / 100
    >>> np.around(log_encoding_VLog(L_in, 10, False) * 100).astype(np.int_)
    array([ 7, 42, 61])
    >>> np.around(log_encoding_VLog(L_in) * (2**10 - 1)).astype(np.int_)
    array([128, 433, 602])
    >>> np.around(log_encoding_VLog(L_in) * (2**12 - 1)).astype(np.int_)
    array([ 512, 1733, 2409])

    Note that some values in the last column values of
    *Fig.2.2 V-Log Code Value* table in :cite:`Panasonic2014a` are different
    by a code: [512, 1732, 2408].
    """

    L_in = to_domain_1(L_in)
    constants = optional(constants, CONSTANTS_VLOG)

    if not in_reflection:
        L_in = L_in * 0.9

    cut1 = constants.cut1
    b = constants.b
    c = constants.c
    d = constants.d

    V_out = np.where(
        L_in < cut1,
        5.6 * L_in + 0.125,
        c * np.log10(L_in + b) + d,
    )

    V_out_cv = V_out if out_normalised_code_value else legal_to_full(V_out, bit_depth)

    return as_float(from_range_1(V_out_cv))


def log_decoding_VLog(
    V_out: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Panasonic V-Log* log decoding inverse opto-electronic transfer

    function (OETF).

    Parameters
    ----------
    V_out
        *Panasonic V-Log* mon-linear encoded data :math:`V_{out}`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Panasonic V-Log* non-linear data :math:`V_{out}` is
        encoded as normalised code values.
    out_reflection
        Whether the light level :math:`L_{in}` to a camera is reflection.
    constants
        *Panasonic V-Log* constants.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear reflection data :math:`L_{in}`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``V_out``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``L_in``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Panasonic2014a`

    Examples
    --------
    >>> log_decoding_VLog(0.423311448760136)  # doctest: +ELLIPSIS
    0.1799999...
    """

    V_out = to_domain_1(V_out)
    constants = optional(constants, CONSTANTS_VLOG)

    V_out = V_out if in_normalised_code_value else full_to_legal(V_out, bit_depth)

    cut2 = constants.cut2
    b = constants.b
    c = constants.c
    d = constants.d

    L_in = np.where(
        V_out < cut2,
        (V_out - 0.125) / 5.6,
        10 ** ((V_out - d) / c) - b,
    )

    if not out_reflection:
        L_in = L_in / 0.9

    return as_float(from_range_1(L_in))
"""
Canon Log Encodings
===================

Define the *Canon Log* encodings.

-   :attr:`colour.models.CANON_LOG_ENCODING_METHODS`
-   :func:`colour.models.log_encoding_CanonLog`
-   :attr:`colour.models.CANON_LOG_DECODING_METHODS`
-   :func:`colour.models.log_decoding_CanonLog`
-   :attr:`colour.models.CANON_LOG_2_ENCODING_METHODS`
-   :func:`colour.models.log_encoding_CanonLog2`
-   :attr:`colour.models.CANON_LOG_2_DECODING_METHODS`
-   :func:`colour.models.log_decoding_CanonLog2`
-   :attr:`colour.models.CANON_LOG_3_ENCODING_METHODS`
-   :func:`colour.models.log_encoding_CanonLog3`
-   :attr:`colour.models.CANON_LOG_3_DECODING_METHODS`
-   :func:`colour.models.log_decoding_CanonLog3`

Notes
-----
-   :cite:`Canon2016` is available as a *Drivers & Downloads* *Software* for
    Windows 7 *Operating System*, a copy of the archive is hosted at
    this url: https://drive.google.com/open?id=0B_IQZQdc4Vy8ZGYyY29pMEVwZU0
-   :cite:`Canon2020` is available as a *Drivers & Downloads* *Software* for
    Windows 10 *Operating System*, a copy of the archive is hosted at
    this url: https://drive.google.com/open?id=1Vcz8RVIXgXL54lhZsOwGUjjVZRObZSc5

References
----------
-   :cite:`Canon2016` : Canon. (2016). Input Transform Version 201612 for EOS
    C300 Mark II. Retrieved August 23, 2016, from https://www.usa.canon.com/\
internet/portal/us/home/support/details/cameras/cinema-eos/eos-c300-mark-ii
-   :cite:`Canon2020` : Canon. (2020). Input Transform Version 202007 for EOS
    C300 Mark II. Retrieved July 16, 2023, from https://www.usa.canon.com/\
internet/portal/us/home/support/details/cameras/cinema-eos/eos-c300-mark-ii
-   :cite:`Thorpe2012a` : Thorpe, L. (2012). CANON-LOG TRANSFER CHARACTERISTIC.
    Retrieved September 25, 2014, from
    http://downloads.canon.com/CDLC/Canon-Log_Transfer_Characteristic_6-20-2012.pdf
"""

from __future__ import annotations

import typing

import numpy as np

if typing.TYPE_CHECKING:
    from colour.hints import Literal

from colour.hints import (  # noqa: TC001
    Domain1,
    Range1,
)
from colour.models.rgb.transfer_functions import full_to_legal, legal_to_full
from colour.utilities import (
    CanonicalMapping,
    as_float,
    domain_range_scale,
    from_range_1,
    to_domain_1,
    validate_method,
)

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "log_encoding_CanonLog_v1",
    "log_decoding_CanonLog_v1",
    "log_encoding_CanonLog_v1_2",
    "log_decoding_CanonLog_v1_2",
    "CANON_LOG_ENCODING_METHODS",
    "log_encoding_CanonLog",
    "CANON_LOG_DECODING_METHODS",
    "log_decoding_CanonLog",
    "log_encoding_CanonLog2_v1",
    "log_decoding_CanonLog2_v1",
    "log_encoding_CanonLog2_v1_2",
    "log_decoding_CanonLog2_v1_2",
    "CANON_LOG_2_ENCODING_METHODS",
    "log_encoding_CanonLog2",
    "CANON_LOG_2_DECODING_METHODS",
    "log_decoding_CanonLog2",
    "log_encoding_CanonLog3_v1",
    "log_decoding_CanonLog3_v1",
    "log_encoding_CanonLog3_v1_2",
    "log_decoding_CanonLog3_v1_2",
    "CANON_LOG_3_ENCODING_METHODS",
    "log_encoding_CanonLog3",
    "CANON_LOG_3_DECODING_METHODS",
    "log_decoding_CanonLog3",
]


def log_encoding_CanonLog_v1(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log* v1 log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log* v1 non-linear data is encoded as normalised
        code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log* v1 non-linear encoded data.

    References
    ----------
    :cite:`Canon2016`, :cite:`Thorpe2012a`

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    Examples
    --------
    >>> log_encoding_CanonLog_v1(0.18) * 100  # doctest: +ELLIPSIS
    34.3389651...

    The values of *Table 2 Canon-Log Code Values* table in
    :cite:`Thorpe2012a` are obtained as follows:

    >>> x = np.array([0, 2, 18, 90, 720]) / 100
    >>> np.around(log_encoding_CanonLog_v1(x) * (2**10 - 1)).astype(np.int_)
    array([ 128,  169,  351,  614, 1016])
    >>> np.around(log_encoding_CanonLog_v1(x, 10, False) * 100, 1)
    array([   7.3,   12. ,   32.8,   62.7,  108.7])
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    with domain_range_scale("ignore"):
        clog = np.where(
            x < log_decoding_CanonLog_v1(0.0730597, bit_depth, False),
            -(0.529136 * (np.log10(-x * 10.1596 + 1)) - 0.0730597),
            0.529136 * np.log10(10.1596 * x + 1) + 0.0730597,
        )

    clog_cv = full_to_legal(clog, bit_depth) if out_normalised_code_value else clog

    return as_float(from_range_1(clog_cv))


def log_decoding_CanonLog_v1(
    clog: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log* v1 log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog
        *Canon Log* v1 non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log* v1 non-linear data is encoded with normalised
        code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`, :cite:`Thorpe2012a`

    Examples
    --------
    >>> log_decoding_CanonLog_v1(34.338965172606912 / 100)  # doctest: +ELLIPSIS
    0.17999999...
    """

    clog = to_domain_1(clog)

    clog = legal_to_full(clog, bit_depth) if in_normalised_code_value else clog

    x = np.where(
        clog < 0.0730597,
        -(10 ** ((0.0730597 - clog) / 0.529136) - 1) / 10.1596,
        (10 ** ((clog - 0.0730597) / 0.529136) - 1) / 10.1596,
    )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


def log_encoding_CanonLog_v1_2(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log* v1.2 log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log* v1.2 non-linear data is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log* v1.2 non-linear encoded data.

    References
    ----------
    :cite:`Canon2020`

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    Examples
    --------
    >>> log_encoding_CanonLog_v1_2(0.18) * 100  # doctest: +ELLIPSIS
    34.3389649...
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    with domain_range_scale("ignore"):
        clog = np.where(
            x < (log_decoding_CanonLog_v1_2(0.12512248, bit_depth, True)),
            -(0.45310179 * (np.log10(-x * 10.1596 + 1)) - 0.12512248),
            0.45310179 * np.log10(10.1596 * x + 1) + 0.12512248,
        )

    # NOTE: *Canon Log* v1.2 constants are expressed in legal range
    # (studio swing).
    clog_cv = clog if out_normalised_code_value else legal_to_full(clog, bit_depth)

    return as_float(from_range_1(clog_cv))


def log_decoding_CanonLog_v1_2(
    clog: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log* v1.2 log decoding inverse opto-electronic transfer

    function (OETF).

    Parameters
    ----------
    clog
        *Canon Log* v1.2 non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log* v1.2 non-linear data is encoded with normalised
        code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2020`

    Examples
    --------
    >>> log_decoding_CanonLog_v1_2(34.338964929528061 / 100)
    ... # doctest: +ELLIPSIS
    0.17999999...
    """

    clog = to_domain_1(clog)

    # NOTE: *Canon Log* v1.2 constants are expressed in legal range
    # (studio swing).
    clog = clog if in_normalised_code_value else full_to_legal(clog, bit_depth)

    x = np.where(
        clog < 0.12512248,
        -(10 ** ((0.12512248 - clog) / 0.45310179) - 1) / 10.1596,
        (10 ** ((clog - 0.12512248) / 0.45310179) - 1) / 10.1596,
    )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


CANON_LOG_ENCODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_encoding_CanonLog_v1,
        "v1.2": log_encoding_CanonLog_v1_2,
    }
)
CANON_LOG_ENCODING_METHODS.__doc__ = """
Supported *Canon Log* log encoding curve / opto-electronic transfer function
(OETF) methods.

References
----------
:cite:`Canon2016`, :cite:`Canon2020`
"""


def log_encoding_CanonLog(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    method: Literal["v1", "v1.2"] | str = "v1.2",
) -> Range1:
    """
    Apply the *Canon Log* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log* non-linear data is encoded as normalised
        code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log* non-linear encoded data.

    References
    ----------
    :cite:`Canon2016`, :cite:`Canon2020`, :cite:`Thorpe2012a`

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    Examples
    --------
    >>> log_encoding_CanonLog(0.18) * 100  # doctest: +ELLIPSIS
    34.3389649...
    >>> log_encoding_CanonLog(0.18, method="v1") * 100  # doctest: +ELLIPSIS
    34.3389651...

    The values of *Table 2 Canon-Log Code Values* table in
    :cite:`Thorpe2012a` are obtained as follows:

    >>> x = np.array([0, 2, 18, 90, 720]) / 100
    >>> np.around(log_encoding_CanonLog(x, method="v1") * (2**10 - 1)).astype(np.int_)
    array([ 128,  169,  351,  614, 1016])
    >>> np.around(log_encoding_CanonLog(x, 10, False, method="v1") * 100, 1)
    array([   7.3,   12. ,   32.8,   62.7,  108.7])
    """

    method = validate_method(method, tuple(CANON_LOG_ENCODING_METHODS))

    return CANON_LOG_ENCODING_METHODS[method](
        x, bit_depth, out_normalised_code_value, in_reflection
    )


CANON_LOG_DECODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_decoding_CanonLog_v1,
        "v1.2": log_decoding_CanonLog_v1_2,
    }
)
CANON_LOG_DECODING_METHODS.__doc__ = """
Supported *Canon Log* log decoding curve / electro-optical transfer function
(EOTF) methods.

References
----------
:cite:`Canon2016`, :cite:`Canon2020`
"""


def log_decoding_CanonLog(
    clog: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    method: Literal["v1", "v1.2"] | str = "v1.2",
) -> Range1:
    """
    Apply the *Canon Log* log decoding inverse opto-electronic transfer function (OETF).

    Parameters
    ----------
    clog
        *Canon Log* non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log* non-linear data is encoded with normalised
        code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog``   | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`, :cite:`Canon2020`, :cite:`Thorpe2012a`

    Examples
    --------
    >>> log_decoding_CanonLog(34.338964929528061 / 100)  # doctest: +ELLIPSIS
    0.17999999...
    >>> log_decoding_CanonLog(34.338965172606912 / 100, method="v1")
    ... # doctest: +ELLIPSIS
    0.17999999...
    """

    method = validate_method(method, tuple(CANON_LOG_DECODING_METHODS))

    return CANON_LOG_DECODING_METHODS[method](
        clog, bit_depth, in_normalised_code_value, out_reflection
    )


def log_encoding_CanonLog2_v1(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 2* v1 log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log 2* v1 non-linear data is encoded as normalised
        code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log 2* v1 non-linear encoded data.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog2``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`

    Examples
    --------
    >>> log_encoding_CanonLog2_v1(0.18) * 100  # doctest: +ELLIPSIS
    39.8254694...
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    with domain_range_scale("ignore"):
        clog2 = np.where(
            x < log_decoding_CanonLog2_v1(0.035388128, bit_depth, False),
            -(0.281863093 * (np.log10(-x * 87.09937546 + 1)) - 0.035388128),
            0.281863093 * np.log10(x * 87.09937546 + 1) + 0.035388128,
        )

    clog2_cv = full_to_legal(clog2, bit_depth) if out_normalised_code_value else clog2

    return as_float(from_range_1(clog2_cv))


def log_decoding_CanonLog2_v1(
    clog2: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 2* v1 log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog2
        *Canon Log 2* v1 non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log 2* v1 non-linear data is encoded with
        normalised code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog2``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`

    Examples
    --------
    >>> log_decoding_CanonLog2_v1(39.825469498316735 / 100)  # doctest: +ELLIPSIS
    0.1799999...
    """

    clog2 = to_domain_1(clog2)

    clog2 = legal_to_full(clog2, bit_depth) if in_normalised_code_value else clog2

    x = np.where(
        clog2 < 0.035388128,
        -(10 ** ((0.035388128 - clog2) / 0.281863093) - 1) / 87.09937546,
        (10 ** ((clog2 - 0.035388128) / 0.281863093) - 1) / 87.09937546,
    )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


def log_encoding_CanonLog2_v1_2(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 2* v1.2 log encoding opto-electronic transfer function
    (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log 2* v1.2 non-linear data is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log 2* v1.2 non-linear encoded data.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog2``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2020`

    Examples
    --------
    >>> log_encoding_CanonLog2_v1_2(0.18) * 100  # doctest: +ELLIPSIS
    39.8254692...
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    with domain_range_scale("ignore"):
        clog2 = np.where(
            x < (log_decoding_CanonLog2_v1_2(0.092864125, bit_depth, True)),
            -(0.24136077 * (np.log10(-x * 87.09937546 + 1)) - 0.092864125),
            0.24136077 * np.log10(x * 87.09937546 + 1) + 0.092864125,
        )

    # NOTE: *Canon Log 2* v1.2 constants are expressed in legal range
    # (studio swing).
    clog2_cv = clog2 if out_normalised_code_value else legal_to_full(clog2, bit_depth)

    return as_float(from_range_1(clog2_cv))


def log_decoding_CanonLog2_v1_2(
    clog2: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 2* v1.2 log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog2
        *Canon Log 2* v1.2 non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log 2* v1.2 non-linear data is encoded with normalised
        code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog2``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2020`

    Examples
    --------
    >>> log_decoding_CanonLog2_v1_2(39.825469256149191 / 100)
    ... # doctest: +ELLIPSIS
    0.1799999...
    """

    clog2 = to_domain_1(clog2)

    # NOTE: *Canon Log 2* v1.2 constants are expressed in legal range
    # (studio swing).
    clog2 = clog2 if in_normalised_code_value else full_to_legal(clog2, bit_depth)

    x = np.where(
        clog2 < 0.092864125,
        -(10 ** ((0.092864125 - clog2) / 0.24136077) - 1) / 87.09937546,
        (10 ** ((clog2 - 0.092864125) / 0.24136077) - 1) / 87.09937546,
    )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


CANON_LOG_2_ENCODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_encoding_CanonLog2_v1,
        "v1.2": log_encoding_CanonLog2_v1_2,
    }
)
CANON_LOG_2_ENCODING_METHODS.__doc__ = """
Supported *Canon Log 2* log encoding curve / opto-electronic transfer function
(OETF) methods.

References
----------
:cite:`Canon2016`, :cite:`Canon2020`
"""


def log_encoding_CanonLog2(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    method: Literal["v1", "v1.2"] | str = "v1.2",
) -> Range1:
    """
    Apply the *Canon Log 2* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log 2* non-linear data is encoded as normalised
        code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log 2* non-linear encoded data.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog2``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`, :cite:`Canon2020`

    Examples
    --------
    >>> log_encoding_CanonLog2(0.18) * 100  # doctest: +ELLIPSIS
    39.8254692...
    """

    method = validate_method(method, tuple(CANON_LOG_2_ENCODING_METHODS))

    return CANON_LOG_2_ENCODING_METHODS[method](
        x, bit_depth, out_normalised_code_value, in_reflection
    )


CANON_LOG_2_DECODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_decoding_CanonLog2_v1,
        "v1.2": log_decoding_CanonLog2_v1_2,
    }
)
CANON_LOG_2_DECODING_METHODS.__doc__ = """
Supported *Canon Log 2* log decoding curve / electro-optical transfer function
(EOTF) methods.

References
----------
:cite:`Canon2016`, :cite:`Canon2020`
"""


def log_decoding_CanonLog2(
    clog2: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    method: Literal["v1", "v1.2"] | str = "v1.2",
) -> Range1:
    """
    Apply the *Canon Log 2* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog2
        *Canon Log 2* non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log 2* non-linear data is encoded with normalised
        code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog2``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`, :cite:`Canon2020`

    Examples
    --------
    >>> log_decoding_CanonLog2(39.825469256149191 / 100)  # doctest: +ELLIPSIS
    0.1799999...
    """

    method = validate_method(method, tuple(CANON_LOG_2_DECODING_METHODS))

    return CANON_LOG_2_DECODING_METHODS[method](
        clog2, bit_depth, in_normalised_code_value, out_reflection
    )


def log_encoding_CanonLog3_v1(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 3* v1 log encoding opto-electronic transfer function
    (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log 3* v1 non-linear data is encoded as
        normalised code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log 3* v1 non-linear encoded data.

    Notes
    -----
    -   Introspection of the grafting points by Shaw, N. (2018) shows
        that the *Canon Log 3* v1 IDT was likely derived from its
        encoding curve as the latter is grafted at *+/-0.014*::

            >>> clog3 = 0.04076162
            >>> (clog3 - 0.073059361) / 2.3069815
            -0.014000000000000002
            >>> clog3 = 0.105357102
            >>> (clog3 - 0.073059361) / 2.3069815
            0.013999999999999997

    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog3``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`

    Examples
    --------
    >>> log_encoding_CanonLog3_v1(0.18) * 100  # doctest: +ELLIPSIS
    34.3389369...
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    with domain_range_scale("ignore"):
        clog3 = np.select(
            (
                x < log_decoding_CanonLog3_v1(0.04076162, bit_depth, False, False),
                x <= log_decoding_CanonLog3_v1(0.105357102, bit_depth, False, False),
                x > log_decoding_CanonLog3_v1(0.105357102, bit_depth, False, False),
            ),
            (
                -0.42889912 * np.log10(-x * 14.98325 + 1) + 0.07623209,
                2.3069815 * x + 0.073059361,
                0.42889912 * np.log10(x * 14.98325 + 1) + 0.069886632,
            ),
        )

    clog3_cv = full_to_legal(clog3, bit_depth) if out_normalised_code_value else clog3

    return as_float(from_range_1(clog3_cv))


def log_decoding_CanonLog3_v1(
    clog3: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 3* v1 log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog3
        *Canon Log 3* v1 non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log 3* v1 non-linear data is encoded with
        normalised code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog3``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`

    Examples
    --------
    >>> log_decoding_CanonLog3_v1(34.338936938868677 / 100)  # doctest: +ELLIPSIS
    0.1800000...
    """

    clog3 = to_domain_1(clog3)

    clog3 = legal_to_full(clog3, bit_depth) if in_normalised_code_value else clog3

    x = np.select(
        (clog3 < 0.04076162, clog3 <= 0.105357102, clog3 > 0.105357102),
        (
            -(10 ** ((0.07623209 - clog3) / 0.42889912) - 1) / 14.98325,
            (clog3 - 0.073059361) / 2.3069815,
            (10 ** ((clog3 - 0.069886632) / 0.42889912) - 1) / 14.98325,
        ),
    )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


def log_encoding_CanonLog3_v1_2(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 3* v1.2 log encoding opto-electronic transfer function
    (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log 3* v1.2 non-linear data is encoded as normalised
        code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log 3* v1.2 non-linear encoded data.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog3``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2020`

    Examples
    --------
    >>> log_encoding_CanonLog3_v1_2(0.18) * 100  # doctest: +ELLIPSIS
    34.3389370...
    """

    x = to_domain_1(x)

    if in_reflection:
        x = x / 0.9

    with domain_range_scale("ignore"):
        clog3 = np.select(
            (
                x < log_decoding_CanonLog3_v1_2(0.097465473, bit_depth, True, False),
                x <= log_decoding_CanonLog3_v1_2(0.15277891, bit_depth, True, False),
                x > log_decoding_CanonLog3_v1_2(0.15277891, bit_depth, True, False),
            ),
            (
                -0.36726845 * np.log10(-x * 14.98325 + 1) + 0.12783901,
                1.9754798 * x + 0.12512219,
                0.36726845 * np.log10(x * 14.98325 + 1) + 0.12240537,
            ),
        )

    # NOTE: *Canon Log 3* v1.2 constants are expressed in legal range
    # (studio swing).
    clog3_cv = clog3 if out_normalised_code_value else legal_to_full(clog3, bit_depth)

    return as_float(from_range_1(clog3_cv))


def log_decoding_CanonLog3_v1_2(
    clog3: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
) -> Range1:
    """
    Apply the *Canon Log 3* v1.2 log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog3
        *Canon Log 3* v1.2 non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log 3* v1.2 non-linear data is encoded with
        normalised code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog3``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2020`

    Examples
    --------
    >>> log_decoding_CanonLog3_v1_2(34.338937037393549 / 100)
    ... # doctest: +ELLIPSIS
    0.1799999...
    """

    clog3 = to_domain_1(clog3)

    # NOTE: *Canon Log 3* v1.2 constants are expressed in legal range
    # (studio swing).
    clog3 = clog3 if in_normalised_code_value else full_to_legal(clog3, bit_depth)

    x = np.select(
        (clog3 < 0.097465473, clog3 <= 0.15277891, clog3 > 0.15277891),
        (
            -(10 ** ((0.12783901 - clog3) / 0.36726845) - 1) / 14.98325,
            (clog3 - 0.12512219) / 1.9754798,
            (10 ** ((clog3 - 0.12240537) / 0.36726845) - 1) / 14.98325,
        ),
    )

    if out_reflection:
        x = x * 0.9

    return as_float(from_range_1(x))


CANON_LOG_3_ENCODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_encoding_CanonLog3_v1,
        "v1.2": log_encoding_CanonLog3_v1_2,
    }
)
CANON_LOG_3_ENCODING_METHODS.__doc__ = """
Supported *Canon Log 3* log encoding curve / opto-electronic transfer function
(OETF) methods.

References
----------
:cite:`Canon2016`, :cite:`Canon2020`
"""


def log_encoding_CanonLog3(
    x: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    method: Literal["v1", "v1.2"] | str = "v1.2",
) -> Range1:
    """
    Apply the *Canon Log 3* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether the *Canon Log 3* non-linear data is encoded as normalised
        code values.
    in_reflection
        Whether the light level :math:`x` to a camera is reflection.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        *Canon Log 3* non-linear encoded data.

    Notes
    -----
    -   Introspection of the grafting points by Shaw, N. (2018) shows that
        the *Canon Log 3* v1 IDT was likely derived from its encoding curve
        as the latter is grafted at *+/-0.014*::

            >>> clog3 = 0.04076162
            >>> (clog3 - 0.073059361) / 2.3069815
            -0.014000000000000002
            >>> clog3 = 0.105357102
            >>> (clog3 - 0.073059361) / 2.3069815
            0.013999999999999997

    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog3``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`, :cite:`Canon2020`

    Examples
    --------
    >>> log_encoding_CanonLog3(0.18) * 100  # doctest: +ELLIPSIS
    34.3389370...
    """

    method = validate_method(method, tuple(CANON_LOG_3_ENCODING_METHODS))

    return CANON_LOG_3_ENCODING_METHODS[method](
        x, bit_depth, out_normalised_code_value, in_reflection
    )


CANON_LOG_3_DECODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_decoding_CanonLog3_v1,
        "v1.2": log_decoding_CanonLog3_v1_2,
    }
)
CANON_LOG_3_DECODING_METHODS.__doc__ = """
Supported *Canon Log 3* log decoding curve / electro-optical transfer function
(EOTF) methods.

References
----------
:cite:`Canon2016`, :cite:`Canon2020`
"""


def log_decoding_CanonLog3(
    clog3: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    method: Literal["v1", "v1.2"] | str = "v1.2",
) -> Range1:
    """
    Apply the *Canon Log 3* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    clog3
        *Canon Log 3* non-linear encoded data.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the *Canon Log 3* non-linear data is encoded with normalised
        code values.
    out_reflection
        Whether the light level :math:`x` to a camera is reflection.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``clog3``  | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Canon2016`, :cite:`Canon2020`

    Examples
    --------
    >>> log_decoding_CanonLog3(34.338937037393549 / 100)  # doctest: +ELLIPSIS
    0.1799999...
    """

    method = validate_method(method, tuple(CANON_LOG_3_DECODING_METHODS))

    return CANON_LOG_3_DECODING_METHODS[method](
        clog3, bit_depth, in_normalised_code_value, out_reflection
    )
"""
Nikon N-Log Log Encoding
========================

Define the *Nikon N-Log* log encoding.

-   :func:`colour.models.log_encoding_NLog`
-   :func:`colour.models.log_decoding_NLog`

References
----------
-   :cite:`Nikon2018` : Nikon. (2018). N-Log Specification Document - Version
    1.0.0 (pp. 1-5). Retrieved September 9, 2019, from
    http://download.nikonimglib.com/archive3/hDCmK00m9JDI03RPruD74xpoU905/\
N-Log_Specification_(En)01.pdf
"""

from __future__ import annotations

import numpy as np

from colour.algebra import spow
from colour.hints import (  # noqa: TC001
    Domain1,
    Range1,
)
from colour.models.rgb.transfer_functions import full_to_legal, legal_to_full
from colour.utilities import Structure, as_float, from_range_1, optional, to_domain_1

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "CONSTANTS_NLOG",
    "log_encoding_NLog",
    "log_decoding_NLog",
]

CONSTANTS_NLOG: Structure = Structure(
    cut1=0.328,
    cut2=(452 / 1023),
    a=(650 / 1023),
    b=0.0075,
    c=(150 / 1023),
    d=(619 / 1023),
)
"""*Nikon N-Log* constants."""


def log_encoding_NLog(
    y: Domain1,
    bit_depth: int = 10,
    out_normalised_code_value: bool = True,
    in_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Nikon N-Log* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    y
        Linear light reflectance :math:`y`, where :math:`y = 0.18` represents
        middle grey at Stop 0.
    bit_depth
        Bit-depth used for conversion.
    out_normalised_code_value
        Whether to return the *Nikon N-Log* encoded data :math:`x` as
        normalised code values.
    in_reflection
        Whether the input light level represents reflected light.
    constants
        *Nikon N-Log* constants.

    Returns
    -------
    :class:`numpy.ndarray`
        *N-Log* 10-bit equivalent code value :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nikon2018`

    Examples
    --------
    >>> log_encoding_NLog(0.18)  # doctest: +ELLIPSIS
    0.3636677...
    """

    y = to_domain_1(y)
    constants = optional(constants, CONSTANTS_NLOG)

    if not in_reflection:
        y = y * 0.9

    cut1 = constants.cut1
    a = constants.a
    b = constants.b
    c = constants.c
    d = constants.d

    x = np.where(
        y < cut1,
        a * spow(y + b, 1 / 3),
        c * np.log(y) + d,
    )

    x_cv = x if out_normalised_code_value else legal_to_full(x, bit_depth)

    return as_float(from_range_1(x_cv))


def log_decoding_NLog(
    x: Domain1,
    bit_depth: int = 10,
    in_normalised_code_value: bool = True,
    out_reflection: bool = True,
    constants: Structure | None = None,
) -> Range1:
    """
    Apply the *Nikon N-Log* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    x
        *N-Log* 10-bit equivalent code value :math:`x`.
    bit_depth
        Bit-depth used for conversion.
    in_normalised_code_value
        Whether the non-linear *Nikon N-Log* data :math:`x` is encoded as
        normalised code values.
    out_reflection
        Whether the light level :math:`y` to a camera is reflection.
    constants
        *Nikon N-Log* constants.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear light reflectance :math:`y`, where :math:`y = 0.18` represents
        middle grey at Stop 0.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nikon2018`

    Examples
    --------
    >>> log_decoding_NLog(0.36366777011713869)  # doctest: +ELLIPSIS
    0.1799999...
    """

    x = to_domain_1(x)
    constants = optional(constants, CONSTANTS_NLOG)

    x = x if in_normalised_code_value else full_to_legal(x, bit_depth)

    cut2 = constants.cut2
    a = constants.a
    b = constants.b
    c = constants.c
    d = constants.d

    y = np.where(
        x < cut2,
        spow(x / a, 3) - b,
        np.exp((x - d) / c),
    )

    if not out_reflection:
        y = y / 0.9

    return as_float(from_range_1(y))
"""
DJI D-Log Log Encoding
======================

Define the *DJI D-Log* log encoding.

-   :func:`colour.models.log_encoding_DJIDLog`
-   :func:`colour.models.log_decoding_DJIDLog`

References
----------
-   :cite:`DJI2017` : Dji. (2017). White Paper on D-Log and D-Gamut of DJI
    Cinema Color System (pp. 1-5).
    https://dl.djicdn.com/downloads/zenmuse+x7/20171010/\
D-Log_D-Gamut_Whitepaper.pdf
"""

from __future__ import annotations

import numpy as np

from colour.hints import (  # noqa: TC001
    Domain1,
    Range1,
)
from colour.utilities import as_float, from_range_1, to_domain_1

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "log_encoding_DJIDLog",
    "log_decoding_DJIDLog",
]


def log_encoding_DJIDLog(x: Domain1) -> Range1:
    """
    Apply the *DJI D-Log* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear reflection data :math:`x`.

    Returns
    -------
    :class:`numpy.ndarray`
        *DJI D-Log* non-linear encoded data :math:`y`.

    References
    ----------
    :cite:`DJI2017`

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    Examples
    --------
    >>> log_encoding_DJIDLog(0.18)  # doctest: +ELLIPSIS
    0.3987645...
    """

    x = to_domain_1(x)

    y = np.where(
        x <= 0.0078,
        6.025 * x + 0.0929,
        (np.log10(x * 0.9892 + 0.0108)) * 0.256663 + 0.584555,
    )

    return as_float(from_range_1(y))


def log_decoding_DJIDLog(y: Domain1) -> Range1:
    """
    Apply the *DJI D-Log* log decoding inverse opto-electronic transfer function (OETF).

    Parameters
    ----------
    y
        *DJI D-Log* non-linear encoded data :math:`y`.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear reflection data :math:`x`.

    References
    ----------
    :cite:`DJI2017`

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    Examples
    --------
    >>> log_decoding_DJIDLog(0.3987645561893306)  # doctest: +ELLIPSIS
    0.1799998...
    """

    y = to_domain_1(y)

    x = np.where(
        y <= 0.14,
        (y - 0.0929) / 6.025,
        (10 ** (3.89616 * y - 2.27752) - 0.0108) / 0.9892,
    )

    return as_float(from_range_1(x))
"""
RED Log Encodings
=================

Define the *RED* log encodings.

-   :func:`colour.models.log_encoding_REDLog`
-   :func:`colour.models.log_decoding_REDLog`
-   :func:`colour.models.log_encoding_REDLogFilm`
-   :func:`colour.models.log_decoding_REDLogFilm`
-   :func:`colour.models.log_encoding_Log3G10_v1`
-   :func:`colour.models.log_decoding_Log3G10_v1`
-   :func:`colour.models.log_encoding_Log3G10_v2`
-   :func:`colour.models.log_decoding_Log3G10_v2`
-   :func:`colour.models.log_encoding_Log3G10_v3`
-   :func:`colour.models.log_decoding_Log3G10_v3`
-   :attr:`colour.models.LOG3G10_ENCODING_METHODS`
-   :func:`colour.models.log_encoding_Log3G10`
-   :attr:`colour.models.LOG3G10_DECODING_METHODS`
-   :func:`colour.models.log_decoding_Log3G10`
-   :func:`colour.models.log_encoding_Log3G12`
-   :func:`colour.models.log_decoding_Log3G12`

References
----------
-   :cite:`Nattress2016a` : Nattress, G. (2016). Private Discussion with Shaw,
    N.
-   :cite:`REDDigitalCinema2017` : RED Digital Cinema. (2017). White Paper on
    REDWideGamutRGB and Log3G10. Retrieved January 16, 2021, from
    https://www.red.com/download/white-paper-on-redwidegamutrgb-and-log3g10
-   :cite:`SonyImageworks2012a` : Sony Imageworks. (2012). make.py. Retrieved
    November 27, 2014, from
    https://github.com/imageworks/OpenColorIO-Configs/blob/master/\
nuke-default/make.py
"""

from __future__ import annotations

import typing

import numpy as np

if typing.TYPE_CHECKING:
    from colour.hints import Literal

from colour.hints import (  # noqa: TC001
    ArrayLike,
    Domain1,
    Range1,
)
from colour.models.rgb.transfer_functions import (
    log_decoding_Cineon,
    log_encoding_Cineon,
)
from colour.utilities import (
    CanonicalMapping,
    as_float,
    as_float_array,
    from_range_1,
    to_domain_1,
    validate_method,
)

__author__ = "Colour Developers"
__copyright__ = "Copyright 2013 Colour Developers"
__license__ = "BSD-3-Clause - https://opensource.org/licenses/BSD-3-Clause"
__maintainer__ = "Colour Developers"
__email__ = "colour-developers@colour-science.org"
__status__ = "Production"

__all__ = [
    "log_encoding_REDLog",
    "log_decoding_REDLog",
    "log_encoding_REDLogFilm",
    "log_decoding_REDLogFilm",
    "log_encoding_Log3G10_v1",
    "log_decoding_Log3G10_v1",
    "log_encoding_Log3G10_v2",
    "log_decoding_Log3G10_v2",
    "log_encoding_Log3G10_v3",
    "log_decoding_Log3G10_v3",
    "LOG3G10_ENCODING_METHODS",
    "log_encoding_Log3G10",
    "LOG3G10_DECODING_METHODS",
    "log_decoding_Log3G10",
    "log_encoding_Log3G12",
    "log_decoding_Log3G12",
]


def log_encoding_REDLog(
    x: Domain1,
    black_offset: ArrayLike = 10 ** ((0 - 1023) / 511),
) -> Range1:
    """
    Apply the *REDLog* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    black_offset
        Black offset value.

    Returns
    -------
    :class:`numpy.ndarray`
        *REDLog* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyImageworks2012a`

    Examples
    --------
    >>> log_encoding_REDLog(0.18)  # doctest: +ELLIPSIS
    0.6376218...
    """

    x = to_domain_1(x)
    black_offset = as_float_array(black_offset)

    y = (1023 + 511 * np.log10(x * (1 - black_offset) + black_offset)) / 1023

    return as_float(from_range_1(y))


def log_decoding_REDLog(
    y: Domain1,
    black_offset: ArrayLike = 10 ** ((0 - 1023) / 511),
) -> Range1:
    """
    Apply the *REDLog* log decoding inverse opto-electronic transfer function (OETF).

    Parameters
    ----------
    y
        *REDLog* non-linear encoded data :math:`y`.
    black_offset
        Black offset value.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyImageworks2012a`

    Examples
    --------
    >>> log_decoding_REDLog(0.637621845988175)  # doctest: +ELLIPSIS
    0.1...
    """

    y = to_domain_1(y)
    black_offset = as_float_array(black_offset)

    x = ((10 ** ((1023 * y - 1023) / 511)) - black_offset) / (1 - black_offset)

    return as_float(from_range_1(x))


def log_encoding_REDLogFilm(
    x: Domain1,
    black_offset: ArrayLike = 10 ** ((95 - 685) / 300),
) -> Range1:
    """
    Apply the *REDLogFilm* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    black_offset
        Black offset value.

    Returns
    -------
    :class:`numpy.ndarray`
        *REDLogFilm* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyImageworks2012a`

    Examples
    --------
    >>> log_encoding_REDLogFilm(0.18)  # doctest: +ELLIPSIS
    0.4573196...
    """

    return log_encoding_Cineon(x, black_offset)


def log_decoding_REDLogFilm(
    y: Domain1,
    black_offset: ArrayLike = 10 ** ((95 - 685) / 300),
) -> Range1:
    """
    Apply the *REDLogFilm* log decoding inverse opto-electronic transfer
    function (OETF).

    Parameters
    ----------
    y
        *REDLogFilm* non-linear encoded data :math:`y`.
    black_offset
        Black offset value.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`SonyImageworks2012a`

    Examples
    --------
    >>> log_decoding_REDLogFilm(0.457319613085418)  # doctest: +ELLIPSIS
    0.1799999...
    """

    return log_decoding_Cineon(y, black_offset)


def log_encoding_Log3G10_v1(x: Domain1) -> Range1:
    """
    Apply the *Log3G10* *v1* log encoding opto-electronic transfer function (OETF).

    From *REDCINE-X PRO Beta 42* and *Resolve 12.5.2*.

    Parameters
    ----------
    x
        Linear data :math:`x`.

    Returns
    -------
    :class:`numpy.ndarray`
        *Log3G10* *v1* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`

    Examples
    --------
    >>> log_encoding_Log3G10_v1(0.18)  # doctest: +ELLIPSIS
    0.3333336...
    """

    x = to_domain_1(x)

    y = np.sign(x) * 0.222497 * np.log10((np.abs(x) * 169.379333) + 1)

    return as_float(from_range_1(y))


def log_decoding_Log3G10_v1(y: Domain1) -> Range1:
    """
    Apply the *Log3G10* *v1* log decoding inverse opto-electronic transfer
    function (OETF).

    From *REDCINE-X PRO Beta 42* and *Resolve 12.5.2*.

    Parameters
    ----------
    y
        *Log3G10* *v1* non-linear encoded data :math:`y`.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`

    Examples
    --------
    >>> log_decoding_Log3G10_v1(1.0 / 3)  # doctest: +ELLIPSIS
    0.1799994...
    """

    y = to_domain_1(y)

    x = np.sign(y) * (10.0 ** (np.abs(y) / 0.222497) - 1) / 169.379333

    return as_float(from_range_1(x))


def log_encoding_Log3G10_v2(x: Domain1) -> Range1:
    """
    Apply the *Log3G10* *v2* log encoding opto-electronic transfer function (OETF).

    Current curve used in *REDCINE-X PRO*.

    Parameters
    ----------
    x
        Linear data :math:`x`.

    Returns
    -------
    :class:`numpy.ndarray`
       *Log3G10* *v2* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`

    Examples
    --------
    >>> log_encoding_Log3G10_v2(0.0)  # doctest: +ELLIPSIS
    0.0915514...
    """

    x = to_domain_1(x)

    y = np.sign(x + 0.01) * 0.224282 * np.log10((np.abs(x + 0.01) * 155.975327) + 1)

    return as_float(from_range_1(y))


def log_decoding_Log3G10_v2(y: Domain1) -> Range1:
    """
    Apply the *Log3G10* *v2* log decoding inverse opto-electronic transfer
    function (OETF).

    Current curve used in *REDCINE-X PRO*.

    Parameters
    ----------
    y
       *Log3G10* *v2* non-linear encoded data :math:`y`.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`

    Examples
    --------
    >>> log_decoding_Log3G10_v2(1.0)  # doctest: +ELLIPSIS
    184.3223476...
    """

    y = to_domain_1(y)

    x = (np.sign(y) * (10.0 ** (np.abs(y) / 0.224282) - 1) / 155.975327) - 0.01

    return as_float(from_range_1(x))


def log_encoding_Log3G10_v3(x: Domain1) -> Range1:
    """
    Apply the *Log3G10* *v3* log encoding opto-electronic transfer function (OETF).

    As described in the *RedLog3G10* whitepaper.

    Parameters
    ----------
    x
        Linear data :math:`x`.

    Returns
    -------
    :class:`numpy.ndarray`
        *Log3G10* *v3* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`REDDigitalCinema2017`

    Examples
    --------
    >>> log_encoding_Log3G10_v3(0.0)  # doctest: +ELLIPSIS
    0.09155148...
    """

    a = 0.224282
    b = 155.975327
    c = 0.01
    g = 15.1927

    x = to_domain_1(x)

    x = x + c

    y = np.where(x < 0.0, x * g, np.sign(x) * a * np.log10((np.abs(x) * b) + 1.0))

    return as_float(from_range_1(y))


def log_decoding_Log3G10_v3(y: Domain1) -> Range1:
    """
    Apply the *Log3G10* *v3* log decoding inverse opto-electronic transfer
    function (OETF).

    As described in the *RedLog3G10* whitepaper.

    Parameters
    ----------
    y
        *Log3G10* *v3* non-linear encoded data :math:`y`.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear *Log3G10* *v3* data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`REDDigitalCinema2017`

    Examples
    --------
    >>> log_decoding_Log3G10_v3(1.0)  # doctest: +ELLIPSIS
    184.32234764...
    """

    a = 0.224282
    b = 155.975327
    c = 0.01
    g = 15.1927

    y = to_domain_1(y)

    x = np.where(
        y < 0.0,
        (y / g) - c,
        np.sign(y) * (10 ** (np.abs(y) / a) - 1.0) / b - c,
    )

    return as_float(from_range_1(x))


LOG3G10_ENCODING_METHODS: CanonicalMapping = CanonicalMapping(
    {
        "v1": log_encoding_Log3G10_v1,
        "v2": log_encoding_Log3G10_v2,
        "v3": log_encoding_Log3G10_v3,
    }
)
LOG3G10_ENCODING_METHODS.__doc__ = """
Supported *Log3G10* log encoding curve / opto-electronic transfer (OETF)
function methods.

References
----------
:cite:`Nattress2016a`, :cite:`REDDigitalCinema2017`
"""


def log_encoding_Log3G10(
    x: Domain1,
    method: Literal["v1", "v2", "v3"] | str = "v3",
) -> Range1:
    """
    Apply the *Log3G10* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        *Log3G10* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    -   The *Log3G10* *v1* log encoding curve is the one used in
        *REDCINE-X Beta 42*. *Resolve 12.5.2* also uses the *v1* curve.
        *RED* is planning to use the *Log3G10* *v2* log encoding curve in
        the release version of the *RED SDK*.
    -   The intent of the *Log3G10* *v1* log encoding curve is that zero
        maps to zero, 0.18 maps to 1/3, and 10 stops above 0.18 maps to
        1.0. The name indicates this in a similar way to the naming
        conventions of *Sony HyperGamma* curves.

        The constants used in the functions do not in fact quite hit these
        values, but rather than use corrected constants, the functions here
        use the official *RED* values, in order to match the output of the
        *RED SDK*.

        For those interested, solving for constants which exactly hit 1/3
        and 1.0 yields the following values::

            B = 25 * (np.sqrt(4093.0) - 3) / 9
            A = 1 / np.log10(B * 184.32 + 1)

        where the function takes the form::

            Log3G10(x) = A * np.log10(B * x + 1)

        Similarly for *Log3G12*, the values which hit exactly 1/3 and 1.0
        are::

            B = 25 * (np.sqrt(16381.0) - 3) / 9
            A = 1 / np.log10(B * 737.28 + 1)

    References
    ----------
    :cite:`Nattress2016a`, :cite:`REDDigitalCinema2017`

    Examples
    --------
    >>> log_encoding_Log3G10(0.0)  # doctest: +ELLIPSIS
    0.09155148...
    >>> log_encoding_Log3G10(0.18, method="v1")  # doctest: +ELLIPSIS
    0.3333336...
    """

    method = validate_method(method, tuple(LOG3G10_ENCODING_METHODS))

    return LOG3G10_ENCODING_METHODS[method](x)


LOG3G10_DECODING_METHODS = CanonicalMapping(
    {
        "v1": log_decoding_Log3G10_v1,
        "v2": log_decoding_Log3G10_v2,
        "v3": log_decoding_Log3G10_v3,
    }
)
LOG3G10_DECODING_METHODS.__doc__ = """
Supported *Log3G10* log decoding curve / electro-optical transfer (EOTF)
function methods.

References
----------
:cite:`Nattress2016a`, :cite:`REDDigitalCinema2017`
"""


def log_decoding_Log3G10(
    y: Domain1, method: Literal["v1", "v2", "v3"] | str = "v3"
) -> Range1:
    """
    Apply the *Log3G10* log decoding inverse opto-electronic transfer function (OETF).

    Parameters
    ----------
    y
        *Log3G10* non-linear encoded data :math:`y`.
    method
        Computation method.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`, :cite:`REDDigitalCinema2017`

    Examples
    --------
    >>> log_decoding_Log3G10(1.0)  # doctest: +ELLIPSIS
    184.3223476...
    >>> log_decoding_Log3G10(1.0 / 3, method="v1")  # doctest: +ELLIPSIS
    0.1799994...
    """

    method = validate_method(method, tuple(LOG3G10_DECODING_METHODS))

    return LOG3G10_DECODING_METHODS[method](y)


def log_encoding_Log3G12(x: Domain1) -> Range1:
    """
    Apply the *Log3G12* log encoding opto-electronic transfer function (OETF).

    Parameters
    ----------
    x
        Linear data :math:`x`.

    Returns
    -------
    :class:`numpy.ndarray`
        *Log3G12* non-linear encoded data :math:`y`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`, :cite:`REDDigitalCinema2017`

    Examples
    --------
    >>> log_encoding_Log3G12(0.18)  # doctest: +ELLIPSIS
    0.3333326...
    """

    x = to_domain_1(x)

    y = np.sign(x) * 0.184904 * np.log10((np.abs(x) * 347.189667) + 1)

    return as_float(from_range_1(y))


def log_decoding_Log3G12(y: Domain1) -> Range1:
    """
    Apply the *Log3G12* log decoding inverse opto-electronic transfer function (OETF).

    Parameters
    ----------
    y
        *Log3G12* non-linear encoded data :math:`y`.

    Returns
    -------
    :class:`numpy.ndarray`
        Linear data :math:`x`.

    Notes
    -----
    +------------+-----------------------+---------------+
    | **Domain** | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``y``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    +------------+-----------------------+---------------+
    | **Range**  | **Scale - Reference** | **Scale - 1** |
    +============+=======================+===============+
    | ``x``      | 1                     | 1             |
    +------------+-----------------------+---------------+

    References
    ----------
    :cite:`Nattress2016a`, :cite:`REDDigitalCinema2017`

    Examples
    --------
    >>> log_decoding_Log3G12(1.0 / 3)  # doctest: +ELLIPSIS
    0.1800015...
    """

    y = to_domain_1(y)

    x = np.sign(y) * (10.0 ** (np.abs(y) / 0.184904) - 1) / 347.189667

    return as_float(from_range_1(x))
