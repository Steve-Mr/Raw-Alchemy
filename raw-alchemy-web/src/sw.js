import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { openDB } from 'idb'

cleanupOutdatedCaches()

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST)

// Allow the web app to trigger skipWaiting via message
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

const SHARE_TARGET_DB_NAME = 'nitrate-grain-share';
const SHARE_TARGET_STORE_NAME = 'shared-files';

async function saveSharedFile(file) {
  const db = await openDB(SHARE_TARGET_DB_NAME, 1, {
    upgrade(db) {
      db.createObjectStore(SHARE_TARGET_STORE_NAME, { keyPath: 'id', autoIncrement: true });
    },
  });

  // Clear old entries to keep it clean (optional, but good for single-share flow)
  await db.clear(SHARE_TARGET_STORE_NAME);

  await db.add(SHARE_TARGET_STORE_NAME, {
    file,
    timestamp: Date.now()
  });
}

// Handle the Share Target POST request
registerRoute(
  ({ url, request }) => url.pathname === '/share-target/' && request.method === 'POST',
  async ({ request }) => {
    try {
      const formData = await request.formData();
      // The field name 'file' must match the 'name' property in the manifest's share_target.params.files
      const file = formData.get('file');

      if (file) {
        await saveSharedFile(file);
        // Redirect to the root with a query param to indicate a shared file is pending
        return Response.redirect('/?shared_target=true', 303);
      }

      return Response.redirect('/', 303);
    } catch (err) {
      console.error('Share Target Error:', err);
      return Response.redirect('/?error=share_failed', 303);
    }
  },
  'POST'
);
